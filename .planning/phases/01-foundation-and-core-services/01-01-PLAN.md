---
phase: 01-foundation-and-core-services
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - package.json
  - tsconfig.json
  - src/services/config.ts
  - src/services/errors.ts
  - src/types/index.ts
autonomous: true
requirements: [CONFIG-01]

must_haves:
  truths:
    - "Tool stores API keys in config file with 0600 permissions"
    - "Config file is created automatically on first use"
    - "Tool can read and write API key values"
  artifacts:
    - path: "package.json"
      provides: "Project dependencies and metadata"
      contains: "conf"
    - path: "tsconfig.json"
      provides: "TypeScript configuration with ESM support"
      contains: "module"
    - path: "src/services/config.ts"
      provides: "Configuration management service"
      exports: ["ConfigService"]
      min_lines: 40
    - path: "src/services/errors.ts"
      provides: "Custom error types with user-friendly messages"
      exports: ["ZoomBGError", "ConfigPermissionError"]
      min_lines: 20
    - path: "src/types/index.ts"
      provides: "Shared TypeScript type definitions"
      min_lines: 10
  key_links:
    - from: "src/services/config.ts"
      to: "conf library"
      via: "import Conf"
      pattern: "import.*Conf.*from.*'conf'"
    - from: "src/services/config.ts"
      to: "node:fs/promises"
      via: "chmod call for 0600 permissions"
      pattern: "chmod.*0o600"
---

<objective>
Initialize Node.js project with TypeScript, establish configuration service with secure API key storage (0600 permissions), and create foundational error handling types.

Purpose: Provides the baseline project structure and configuration management that all other services depend on. Security patterns (file permissions) must be established correctly from the start - retrofitting would be a breaking change.

Output: Working TypeScript project with secure config storage, ready for service implementation.
</objective>

<execution_context>
@/Users/tvellore/.claude/get-shit-done/workflows/execute-plan.md
@/Users/tvellore/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@/Users/tvellore/work/.planning/PROJECT.md
@/Users/tvellore/work/.planning/ROADMAP.md
@/Users/tvellore/work/.planning/STATE.md
@/Users/tvellore/work/.planning/phases/01-foundation-and-core-services/01-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Initialize Node.js project with TypeScript and dependencies</name>
  <files>package.json, tsconfig.json, .gitignore</files>
  <action>
    Create Node.js project with TypeScript configuration:

    1. Initialize package.json with ESM type ("type": "module")
    2. Install dependencies:
       - Production: conf@15.x, @huggingface/inference@4.x
       - Dev: typescript@5.x, @types/node@latest, tsx@latest (for running TS directly)
    3. Create tsconfig.json with:
       - "module": "ESNext", "target": "ES2022"
       - "moduleResolution": "bundler"
       - "strict": true, "esModuleInterop": true
       - "outDir": "./dist", "rootDir": "./src"
       - "types": ["node"]
    4. Create .gitignore with: node_modules/, dist/, *.log, .DS_Store
    5. Add package.json scripts:
       - "build": "tsc"
       - "dev": "tsx watch src/index.ts"

    Use ESM module syntax throughout (import/export not require).
  </action>
  <verify>
    - npm install completes without errors
    - tsc --noEmit validates TypeScript configuration
    - package.json shows "type": "module" and correct dependencies
  </verify>
  <done>
    Project has package.json with dependencies installed, tsconfig.json configured for ESM, and .gitignore created.
  </done>
</task>

<task type="auto">
  <name>Create configuration service with secure file permissions</name>
  <files>src/services/config.ts</files>
  <action>
    Create ConfigService class that manages API key storage with enforced 0600 permissions:

    1. Import Conf from 'conf' and chmod from 'node:fs/promises'
    2. Define schema with:
       - huggingfaceApiKey: string, default ''
       - openaiApiKey: string, default ''
       - stabilityApiKey: string, default ''
       - lastUsedService: string, default 'huggingface'
    3. Implement ConfigService class:
       - Constructor: Initialize Conf with projectName 'zoombg', schema, then call enforceSecurePermissions()
       - enforceSecurePermissions(): async method that runs chmod(this.store.path, 0o600) in try/catch
       - getApiKey(service: string): returns API key for service or undefined
       - setApiKey(service: string, apiKey: string): saves key then re-enforces permissions
       - getLastUsedService(): returns last used service name
       - setLastUsedService(service: string): saves service preference
    4. Export ConfigService as default export

    CRITICAL: Call enforceSecurePermissions() both in constructor AND after setApiKey() to ensure config file is always 0600. Conf library does NOT enforce permissions by default.

    Reference pattern from RESEARCH.md Pattern 2 (lines 130-180).
  </action>
  <verify>
    - src/services/config.ts compiles without TypeScript errors
    - File contains chmod(path, 0o600) call in enforceSecurePermissions method
    - ConfigService class exports methods: getApiKey, setApiKey, getLastUsedService, setLastUsedService
  </verify>
  <done>
    ConfigService exists with secure 0600 permission enforcement, can read/write API keys and service preferences.
  </done>
</task>

<task type="auto">
  <name>Create error types for user-friendly messaging</name>
  <files>src/services/errors.ts, src/types/index.ts</files>
  <action>
    Create custom error classes for domain-specific errors with user-actionable messages:

    1. In src/services/errors.ts:
       - Base class ZoomBGError extends Error with userMessage property
       - ConfigPermissionError extends ZoomBGError (used when chmod fails)
       - ZoomNotInstalledError extends ZoomBGError (for Phase 2)
       - ZoomNotLoggedInError extends ZoomBGError (for Phase 2)
       - AIServiceError extends ZoomBGError (for Phase 3)
       - Each error has technical message (for logs) and userMessage (for display)
       - Export all error classes

    2. In src/types/index.ts:
       - Define Config interface matching schema: { huggingfaceApiKey?: string, openaiApiKey?: string, stabilityApiKey?: string, lastUsedService: string }
       - Define AIService type: 'huggingface' | 'openai' | 'stability'
       - Export all types

    Reference pattern from RESEARCH.md Pattern 3 (lines 186-233).
  </action>
  <verify>
    - src/services/errors.ts exports ZoomBGError, ConfigPermissionError, ZoomNotInstalledError, ZoomNotLoggedInError, AIServiceError
    - src/types/index.ts exports Config interface and AIService type
    - All files compile without TypeScript errors
  </verify>
  <done>
    Error classes exist with user-friendly messages, type definitions exist for config and AI service types.
  </done>
</task>

</tasks>

<verification>
After completing all tasks:

1. Run `npm install` to ensure dependencies are installed
2. Run `tsc --noEmit` to verify TypeScript compilation
3. Check that src/services/config.ts contains `chmod(path, 0o600)` pattern
4. Verify package.json has "type": "module" and correct dependencies (conf, @huggingface/inference)
5. Verify tsconfig.json has ESM configuration (module: ESNext)
</verification>

<success_criteria>
- [ ] package.json exists with dependencies: conf, @huggingface/inference, typescript, @types/node
- [ ] tsconfig.json configured for ESM with strict mode
- [ ] ConfigService enforces 0600 permissions on config file creation and updates
- [ ] Error types exist with user-friendly messages
- [ ] Type definitions exist for Config and AIService
- [ ] `npm install && tsc --noEmit` runs successfully
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-and-core-services/01-01-SUMMARY.md`
</output>
