---
phase: 05-enhancement-polish
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/services/errors.ts
  - src/services/ai/factory.ts
  - src/cli.ts
autonomous: true
requirements: [CONFIG-04]

must_haves:
  truths:
    - User sees actionable error messages for network timeouts
    - User sees actionable error messages for connection failures
    - Tool automatically retries transient failures (rate limits, server errors)
    - Tool enforces timeout limits and provides clear timeout errors
    - User is not left waiting indefinitely on network issues
  artifacts:
    - path: src/services/errors.ts
      provides: NetworkError class with error code translation
      min_lines: 90
      contains: "NetworkError"
    - path: src/services/ai/factory.ts
      provides: Timeout and retry wrappers for AI service calls
      min_lines: 150
      contains: "TimeoutError"
    - path: src/cli.ts
      provides: Enhanced error display with network error detection
      min_lines: 140
      contains: "ETIMEDOUT"
  key_links:
    - from: src/services/ai/factory.ts
      to: src/services/errors.ts
      via: throws NetworkError
      pattern: "throw new NetworkError"
    - from: src/cli.ts
      to: src/services/errors.ts
      via: catches NetworkError
      pattern: "NetworkError"
---

<objective>
Add robust error handling for edge cases (network errors, rate limits, timeouts).

Purpose: Improve user experience during failures by providing actionable error messages and automatically recovering from transient issues. Prevents indefinite hangs and confusing technical errors.

Output: Enhanced error infrastructure with network error translation, timeout enforcement, and automatic retry logic for transient failures.
</objective>

<execution_context>
@/Users/tvellore/.claude/get-shit-done/workflows/execute-plan.md
@/Users/tvellore/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@/Users/tvellore/work/.planning/PROJECT.md
@/Users/tvellore/work/.planning/ROADMAP.md
@/Users/tvellore/work/.planning/STATE.md
@/Users/tvellore/work/.planning/REQUIREMENTS.md
@/Users/tvellore/work/.planning/phases/05-enhancement-polish/05-RESEARCH.md

# Existing implementation
@/Users/tvellore/work/src/services/errors.ts
@/Users/tvellore/work/src/services/ai/factory.ts
@/Users/tvellore/work/src/cli.ts

# To understand service timeout patterns
@/Users/tvellore/work/.planning/phases/04-multi-service-support/04-02-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add NetworkError class and enhance error handling</name>
  <files>src/services/errors.ts</files>
  <action>
Add new NetworkError class to src/services/errors.ts for translating Node.js network errors to user-friendly messages.

Add after the AIServiceError class (around line 66):
```typescript
/**
 * Thrown when network errors occur during operations
 * Translates Node.js error codes to user-actionable messages
 */
export class NetworkError extends ZoomBGError {
  code: string;

  constructor(code: string, operation: string, originalError?: Error) {
    const userMessages: Record<string, string> = {
      'ETIMEDOUT': `Network timeout while ${operation}. Check your internet connection and try again.`,
      'ECONNREFUSED': `Connection refused while ${operation}. The service may be temporarily unavailable.`,
      'ENOTFOUND': `DNS lookup failed while ${operation}. Check your internet connection.`,
      'ECONNRESET': `Connection reset while ${operation}. The service may be experiencing issues.`,
      'EAI_AGAIN': `DNS lookup timeout while ${operation}. Check your DNS settings.`,
      'ENOTFOUND': `Host not found while ${operation}. Check your internet connection.`
    };

    const userMessage = userMessages[code] ||
      `Network error (${code}) while ${operation}. Please try again.`;

    super(
      `Network error ${code}: ${originalError?.message}`,
      userMessage
    );
    this.code = code;
  }
}

/**
 * Thrown when operation times out
 */
export class TimeoutError extends ZoomBGError {
  constructor(operation: string, timeoutMs: number) {
    super(
      `Operation timed out after ${timeoutMs}ms`,
      `${operation} took longer than ${timeoutMs / 1000} seconds. Try a simpler prompt or check your network connection.`
    );
  }
}

/**
 * Thrown when rate limit is exceeded
 */
export class RateLimitError extends ZoomBGError {
  retryAfter?: number;

  constructor(service: string, retryAfter?: number) {
    const retryMessage = retryAfter
      ? `Rate limit will reset in ${retryAfter} seconds.`
      : 'Please wait a few minutes before trying again.';

    super(
      `Rate limit exceeded for ${service}`,
      `You've exceeded the rate limit for ${service}. ${retryMessage}`
    );
    this.retryAfter = retryAfter;
  }
}
```

Research references:
- RESEARCH.md lines 120-159 (Pattern 2: Network error translation)
- RESEARCH.md lines 345-357 (Pitfall 2: Network errors show generic messages)
  </action>
  <verify>
TypeScript compilation:
```bash
npx tsc --noEmit
```

Check error classes exist:
```bash
grep -n "class NetworkError" src/services/errors.ts
grep -n "class TimeoutError" src/services/errors.ts
grep -n "class RateLimitError" src/services/errors.ts
```

All three classes should be found.
  </verify>
  <done>
- NetworkError class added with error code translation
- TimeoutError class added with timeout duration display
- RateLimitError class added with retry guidance
- All classes extend ZoomBGError with userMessage
- TypeScript compiles without errors
  </done>
</task>

<task type="auto">
  <name>Task 2: Add timeout enforcement and retry logic to AI factory</name>
  <files>src/services/ai/factory.ts</files>
  <action>
Read existing src/services/ai/factory.ts to understand current implementation.

Add timeout and retry wrappers for AI service calls. Since p-timeout and p-retry would be new dependencies and research shows they're optional enhancements, implement lightweight wrappers using built-in Promise utilities.

Add these helper functions to src/services/ai/factory.ts:

```typescript
import { NetworkError, TimeoutError, RateLimitError } from '../errors.js';

/**
 * Service-specific timeout values (ms)
 * From Phase 04-02 decisions: HuggingFace 120s, OpenAI 60s, Stability 90s
 */
const SERVICE_TIMEOUTS: Record<string, number> = {
  huggingface: 120000,  // 120 seconds (free tier is slow)
  openai: 60000,        // 60 seconds
  stability: 90000      // 90 seconds
};

/**
 * Wrap promise with timeout enforcement
 */
async function withTimeout<T>(
  promise: Promise<T>,
  timeoutMs: number,
  operation: string
): Promise<T> {
  let timeoutHandle: NodeJS.Timeout;

  const timeoutPromise = new Promise<never>((_, reject) => {
    timeoutHandle = setTimeout(() => {
      reject(new TimeoutError(operation, timeoutMs));
    }, timeoutMs);
  });

  try {
    return await Promise.race([promise, timeoutPromise]);
  } finally {
    clearTimeout(timeoutHandle!);
  }
}

/**
 * Retry transient errors with exponential backoff
 * Retries: 429 (rate limit), 500 (server error), 503 (unavailable), ETIMEDOUT, ECONNREFUSED
 */
async function withRetry<T>(
  fn: () => Promise<T>,
  maxRetries: number = 2,
  initialDelayMs: number = 1000
): Promise<T> {
  let lastError: Error;

  for (let attempt = 0; attempt <= maxRetries; attempt++) {
    try {
      return await fn();
    } catch (error: any) {
      lastError = error;

      // Don't retry on last attempt
      if (attempt === maxRetries) {
        break;
      }

      const statusCode = error?.status || error?.response?.status;

      // Permanent errors - don't retry
      if (statusCode === 401 || statusCode === 400 || statusCode === 403) {
        throw error;
      }

      // Check for transient errors
      const isTransient =
        statusCode === 429 ||  // Rate limit
        statusCode === 500 ||  // Server error
        statusCode === 503 ||  // Service unavailable
        statusCode === 502 ||  // Bad gateway
        ['ETIMEDOUT', 'ECONNREFUSED', 'ECONNRESET'].includes(error.code);

      if (!isTransient) {
        throw error;  // Unknown error, don't retry
      }

      // Transient error - retry with exponential backoff
      const delay = initialDelayMs * Math.pow(2, attempt);
      const jitter = Math.random() * 0.3 * delay;  // Add 0-30% jitter
      const totalDelay = Math.floor(delay + jitter);

      console.log(`Retry attempt ${attempt + 1}/${maxRetries} after ${totalDelay}ms...`);
      await new Promise(resolve => setTimeout(resolve, totalDelay));
    }
  }

  // All retries exhausted
  throw lastError!;
}

/**
 * Enhanced createAIService wrapper with timeout and retry
 */
export function createAIServiceWithResilience(serviceName: string): AIServiceAdapter {
  const service = createAIService(serviceName);  // Use existing factory
  const timeout = SERVICE_TIMEOUTS[serviceName] || 90000;

  // Wrap generateImage method with timeout and retry
  const originalGenerate = service.generateImage.bind(service);

  return {
    ...service,
    generateImage: async (prompt: string) => {
      try {
        return await withRetry(
          () => withTimeout(
            originalGenerate(prompt),
            timeout,
            'generating image'
          )
        );
      } catch (error: any) {
        // Translate network errors
        if (error.code && ['ETIMEDOUT', 'ECONNREFUSED', 'ENOTFOUND', 'ECONNRESET'].includes(error.code)) {
          throw new NetworkError(error.code, 'generating image', error);
        }

        // Translate rate limit errors
        const statusCode = error?.status || error?.response?.status;
        if (statusCode === 429) {
          const retryAfter = error?.response?.headers?.['retry-after'];
          throw new RateLimitError(serviceName, retryAfter ? parseInt(retryAfter) : undefined);
        }

        // Re-throw other errors (AIServiceError, etc.)
        throw error;
      }
    }
  };
}
```

Update the factory to export both versions:
```typescript
// Keep existing createAIService for backward compatibility
export { createAIService } from './factory.js';

// New enhanced version
export { createAIServiceWithResilience };
```

Research references:
- RESEARCH.md lines 161-199 (Pattern 3: Timeout wrapper)
- RESEARCH.md lines 201-256 (Pattern 4: Retry logic with exponential backoff)
- RESEARCH.md lines 358-372 (Pitfall 3: Timeout shorter than service duration)
- RESEARCH.md lines 374-385 (Pitfall 4: Retrying non-transient errors)
- STATE.md lines 76-81 (Service-specific timeouts from Phase 04-02)
  </action>
  <verify>
TypeScript compilation:
```bash
npx tsc --noEmit
```

Check helper functions exist:
```bash
grep -n "withTimeout" src/services/ai/factory.ts
grep -n "withRetry" src/services/ai/factory.ts
grep -n "createAIServiceWithResilience" src/services/ai/factory.ts
```

Verify service timeout constants:
```bash
grep -A3 "SERVICE_TIMEOUTS" src/services/ai/factory.ts
```

Should show: huggingface: 120000, openai: 60000, stability: 90000
  </verify>
  <done>
- withTimeout helper wraps promises with timeout enforcement
- withRetry helper implements exponential backoff for transient errors
- SERVICE_TIMEOUTS constant matches Phase 04-02 decisions
- createAIServiceWithResilience wraps service with timeout and retry
- Network errors translated to NetworkError with codes
- Rate limit errors translated to RateLimitError
- Non-transient errors (401, 400, 403) not retried
- TypeScript compiles without errors
  </done>
</task>

<task type="auto">
  <name>Task 3: Update workflow and CLI to use enhanced error handling</name>
  <files>src/workflows/generate.ts, src/cli.ts</files>
  <action>
Update src/workflows/generate.ts to use resilient AI service factory:

Change import (around line 17):
```typescript
import { createAIServiceWithResilience } from '../services/ai/factory.js';
```

Update service creation (around line 101):
```typescript
const aiService = createAIServiceWithResilience(service as any);
```

Update src/cli.ts to handle new error types in handleError function (around line 87):

```typescript
import { ZoomBGError, NetworkError, TimeoutError, RateLimitError } from './services/errors.js';

function handleError(error: Error | unknown): void {
  if (error instanceof NetworkError) {
    console.error(pc.red('Network Error:'), error.message);
    console.error(pc.yellow('Solution:'), error.userMessage);
    console.error(pc.dim(`Error code: ${error.code}`));
    process.exitCode = 1;
  } else if (error instanceof TimeoutError) {
    console.error(pc.red('Timeout Error:'), error.message);
    console.error(pc.yellow('Solution:'), error.userMessage);
    process.exitCode = 1;
  } else if (error instanceof RateLimitError) {
    console.error(pc.red('Rate Limit Error:'), error.message);
    console.error(pc.yellow('Solution:'), error.userMessage);
    if (error.retryAfter) {
      console.error(pc.dim(`Retry after: ${error.retryAfter} seconds`));
    }
    process.exitCode = 1;
  } else if (error instanceof ZoomBGError) {
    console.error(pc.red('Error:'), error.message);
    console.error(pc.yellow('Solution:'), error.userMessage);
    process.exitCode = 1;
  } else if (error instanceof Error) {
    console.error(pc.red('Error:'), error.message);

    // Provide context for common errors (keep existing code)
    if (error.message.includes('ENOENT')) {
      console.error(pc.yellow('Suggestion:'), 'Check that all required files exist');
    } else if (error.message.includes('EACCES')) {
      console.error(pc.yellow('Suggestion:'), 'Check file permissions');
    } else if (error.message.includes('ETIMEDOUT')) {
      console.error(pc.yellow('Suggestion:'), 'Check your internet connection and try again');
    } else if (error.message.includes('ECONNREFUSED')) {
      console.error(pc.yellow('Suggestion:'), 'The service may be temporarily unavailable');
    }

    process.exitCode = 1;
  } else {
    console.error(pc.red('Unexpected error:'), error);
    process.exitCode = 1;
  }
}
```

Critical requirements:
- Network errors show error code for debugging
- Rate limit errors show retry-after time if available
- Error handling order: specific errors first, then generic ZoomBGError
- Keep existing error message patterns for consistency
- Exit code always 1 on error

Research references:
- RESEARCH.md lines 120-159 (Network error translation)
- RESEARCH.md lines 445-471 (Process exit codes)
- RESEARCH.md lines 386-394 (Pitfall 7: Exit code always 0)
  </action>
  <verify>
TypeScript compilation:
```bash
npx tsc --noEmit
```

Check workflow uses resilient factory:
```bash
grep "createAIServiceWithResilience" src/workflows/generate.ts
```

Check CLI imports new error types:
```bash
grep "NetworkError\|TimeoutError\|RateLimitError" src/cli.ts
```

Verify error handling structure:
```bash
grep -A2 "instanceof NetworkError" src/cli.ts
grep -A2 "instanceof TimeoutError" src/cli.ts
grep -A2 "instanceof RateLimitError" src/cli.ts
```

Build and test with invalid network to trigger errors:
```bash
npm run build
# Test will fail gracefully with network error message
```
  </verify>
  <done>
- Workflow uses createAIServiceWithResilience for AI service creation
- CLI imports all new error types
- CLI handleError handles NetworkError with code display
- CLI handleError handles TimeoutError with user message
- CLI handleError handles RateLimitError with retry-after display
- Error handling order is specific-to-generic
- All errors set process.exitCode = 1
- TypeScript compiles without errors
  </done>
</task>

</tasks>

<verification>
## Manual Testing

Test timeout behavior:
```bash
npm run build

# If possible, test with slow network or service
node dist/cli.js "complex detailed scene" --service huggingface

# Should show retry messages if transient errors occur
# Should fail with clear timeout message if exceeds 120 seconds
```

Test error messages:
```bash
# Simulate network error (disconnect network, then run)
node dist/cli.js "test" --service openai

# Expected: Clear "Network Error" message with actionable solution
```

Test rate limit handling:
```bash
# Make multiple rapid requests to trigger rate limit
for i in {1..5}; do node dist/cli.js "test $i" --service openai; done

# Expected: RateLimitError message with retry guidance
```

## Automated Checks

```bash
# TypeScript compilation
npx tsc --noEmit

# Check error classes exist
grep "class NetworkError" src/services/errors.ts
grep "class TimeoutError" src/services/errors.ts
grep "class RateLimitError" src/services/errors.ts

# Check factory has resilience wrappers
grep "withTimeout" src/services/ai/factory.ts
grep "withRetry" src/services/ai/factory.ts

# Check CLI handles new errors
grep "instanceof NetworkError" src/cli.ts
grep "instanceof TimeoutError" src/cli.ts
```
</verification>

<success_criteria>
1. NetworkError class translates Node.js error codes to user messages
2. TimeoutError class shows operation and timeout duration
3. RateLimitError class shows retry-after time if available
4. AI service calls wrapped with timeout enforcement
5. Transient errors (429, 500, 503, ETIMEDOUT, ECONNREFUSED) automatically retried with exponential backoff
6. Permanent errors (401, 400, 403) not retried
7. CLI displays specific error messages for network, timeout, and rate limit errors
8. Retry attempts shown to user with delay information
9. Service-specific timeouts enforced (HuggingFace 120s, OpenAI 60s, Stability 90s)
10. TypeScript compiles without errors
11. Process exits with code 1 on all error types
</success_criteria>

<output>
After completion, create `.planning/phases/05-enhancement-polish/05-02-SUMMARY.md`
</output>
