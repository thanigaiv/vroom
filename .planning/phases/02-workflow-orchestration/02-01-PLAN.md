---
phase: 02-workflow-orchestration
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/workflows/preview.ts
  - src/utils/cleanup.ts
  - src/utils/html-gen.ts
autonomous: true
requirements: [FLOW-01]

must_haves:
  truths:
    - "Tool opens browser window with generated image preview"
    - "Preview displays image without CORS or file loading errors"
    - "Temporary files are cleaned up after workflow completes"
    - "Ctrl+C during workflow cleans up temporary files before exit"
  artifacts:
    - path: "src/workflows/preview.ts"
      provides: "Browser preview with base64 data URL"
      exports: ["showPreview"]
      min_lines: 50
    - path: "src/utils/cleanup.ts"
      provides: "Resource cleanup with signal handlers"
      exports: ["CleanupManager", "cleanupManager"]
      min_lines: 40
    - path: "src/utils/html-gen.ts"
      provides: "HTML template generation for preview"
      exports: ["generatePreviewHTML"]
      min_lines: 30
  key_links:
    - from: "src/workflows/preview.ts"
      to: "src/utils/html-gen.ts"
      via: "import and call"
      pattern: "generatePreviewHTML\\(imageBuffer\\)"
    - from: "src/workflows/preview.ts"
      to: "open package"
      via: "pathToFileURL + open()"
      pattern: "open\\(fileUrl\\)"
    - from: "src/utils/cleanup.ts"
      to: "process signals"
      via: "SIGINT/SIGTERM handlers"
      pattern: "process\\.on\\('SIGINT'.*cleanup"
---

<objective>
Create browser preview infrastructure with temporary file management and resource cleanup to enable user verification of generated images before saving to Zoom.

Purpose: Establishes the foundation for user-interactive workflow by solving two critical problems: (1) displaying binary image data in browser without CORS/file protocol issues via base64 data URLs, and (2) ensuring temporary resources are cleaned up on all exit paths including interruption.

Output: Preview system that can display any image Buffer in browser, cleanup manager that prevents temp file accumulation, reusable utilities for Phase 2 orchestrator.
</objective>

<execution_context>
@/Users/tvellore/.claude/get-shit-done/workflows/execute-plan.md
@/Users/tvellore/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/REQUIREMENTS.md
@.planning/phases/02-workflow-orchestration/02-RESEARCH.md

# Phase 1 services (already built)
@.planning/phases/01-foundation-and-core-services/01-01-SUMMARY.md
@.planning/phases/01-foundation-and-core-services/01-02-SUMMARY.md
@.planning/phases/01-foundation-and-core-services/01-03-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create HTML template generator with base64 data URL embedding</name>
  <files>src/utils/html-gen.ts</files>
  <action>
Create `src/utils/html-gen.ts` that exports `generatePreviewHTML(imageBuffer: Buffer): string` function.

**Implementation:**
- Convert Buffer to base64 string using `imageBuffer.toString('base64')`
- Construct data URL: `data:image/png;base64,${base64}`
- Return HTML string with:
  - DOCTYPE html
  - Title: "Zoom Background Preview"
  - CSS styling: centered image on dark background (#1a1a1a), max 90vw/90vh with box shadow
  - img tag with src="${dataUrl}" and alt="Generated Background"

**Why base64 data URLs:** Avoids file:// protocol CORS issues that browser security policies may block. Research confirms this approach works universally (RESEARCH.md lines 144-173).

**Do NOT:** Use file:// protocol with separate image file, embed prompt text in HTML (XSS risk), hardcode image dimensions (breaks responsive display).

**Reference:** Research Pattern 2 (lines 144-173) for complete HTML structure.
  </action>
  <verify>
Run `npx tsx -e "import { generatePreviewHTML } from './src/utils/html-gen.js'; const buf = Buffer.from('test'); const html = generatePreviewHTML(buf); console.log(html.includes('data:image/png;base64') && html.includes('<!DOCTYPE html'))"`

Expected output: `true`
  </verify>
  <done>
generatePreviewHTML function exists, accepts Buffer, returns HTML string with base64 data URL and styling, TypeScript compiles without errors.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create resource cleanup manager with signal handlers</name>
  <files>src/utils/cleanup.ts</files>
  <action>
Create `src/utils/cleanup.ts` that exports:
- `CleanupManager` class with `register(cleanup: () => Promise<void>)` and `cleanup()` methods
- `cleanupManager` singleton instance

**Implementation:**
- CleanupManager maintains array of cleanup functions
- Constructor sets up SIGINT and SIGTERM handlers once
- Signal handlers call `cleanup()` then exit with correct code (130 for SIGINT, 143 for SIGTERM)
- `cleanup()` uses `Promise.allSettled()` to attempt all cleanups even if some fail
- Log cleanup failures to console.warn for debugging
- Clear resources array after cleanup

**Why Promise.allSettled:** Ensures all cleanup attempts run even if one fails. Alternative Promise.all would stop at first failure, leaving resources leaked.

**Do NOT:** Use process.exit() without cleanup, skip signal handler registration, use Promise.all instead of allSettled, register handlers on every cleanup (once in constructor is sufficient).

**Reference:** Research Pattern 4 (lines 252-292) for complete cleanup manager implementation.
  </action>
  <verify>
Run `npx tsx -e "import { cleanupManager } from './src/utils/cleanup.js'; let cleaned = false; cleanupManager.register(async () => { cleaned = true; }); await cleanupManager.cleanup(); console.log(cleaned)"`

Expected output: `true`
  </verify>
  <done>
CleanupManager class exists with register/cleanup methods, singleton instance exported, signal handlers registered in constructor, TypeScript compiles without errors.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create browser preview with temporary file management</name>
  <files>src/workflows/preview.ts</files>
  <action>
Create `src/workflows/preview.ts` that exports `showPreview(imageBuffer: Buffer): Promise<string>` function returning temp directory path for later cleanup.

**Implementation:**
1. Import: mkdtemp, writeFile from 'node:fs/promises', pathToFileURL from 'node:url', open from 'open', generatePreviewHTML from '../utils/html-gen.js'
2. Create temp directory: `await mkdtemp(join(tmpdir(), 'zoombg-'))`
3. Generate HTML: `const html = generatePreviewHTML(imageBuffer)`
4. Write HTML file: `await writeFile(join(tempDir, 'preview.html'), html, 'utf8')`
5. Convert to file URL: `const fileUrl = pathToFileURL(htmlPath).href`
6. Open in browser: `await open(fileUrl)` (default wait:false behavior)
7. Return tempDir for caller to cleanup after user approval/rejection

**Why pathToFileURL:** Properly encodes special characters (#, %, spaces) in file paths. Manual file:// construction breaks with these characters (Research pitfall 7, lines 491-507).

**Why NOT cleanup immediately:** Browser needs file to remain until HTML loads. Research pitfall 2 (lines 362-378) confirms premature cleanup causes "file not found" errors.

**Error handling:** Wrap in try-catch, cleanup tempDir on error before re-throwing.

**Do NOT:** Use manual `file://${path}` construction, cleanup temp files immediately after open(), use `wait: true` option (blocks forever, Research pitfall 1 lines 343-358).

**Reference:** Research Pattern 2 (lines 144-214) and Complete Workflow (lines 509-617) for preview implementation.
  </action>
  <verify>
Run verification:
```bash
npx tsx -e "import { showPreview } from './src/workflows/preview.js'; import { rm } from 'node:fs/promises'; const buf = Buffer.from('iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mNk+M9QDwADhgGAWjR9awAAAABJRU5ErkJggg==', 'base64'); const tempDir = await showPreview(buf); console.log('Temp dir:', tempDir); await new Promise(r => setTimeout(r, 2000)); await rm(tempDir, { recursive: true, force: true });"
```

Expected: Browser opens with 1x1 pixel image, temp directory path printed, no errors, cleanup succeeds after 2 seconds.
  </verify>
  <done>
showPreview function exists, creates temp directory, generates HTML with base64 image, opens browser with pathToFileURL, returns temp directory path, handles errors with cleanup, TypeScript compiles without errors.
  </done>
</task>

</tasks>

<verification>
After all tasks complete:

1. **Unit verification:**
```bash
# Test HTML generation
npx tsx -e "import { generatePreviewHTML } from './src/utils/html-gen.js'; const buf = Buffer.from('test'); const html = generatePreviewHTML(buf); console.log('HTML valid:', html.includes('data:image/png;base64') && html.includes('<!DOCTYPE html') && html.includes('1a1a1a'))"

# Test cleanup manager
npx tsx -e "import { cleanupManager } from './src/utils/cleanup.js'; let count = 0; cleanupManager.register(async () => { count++; }); cleanupManager.register(async () => { count++; }); await cleanupManager.cleanup(); console.log('Cleanups run:', count)"
```

2. **Integration verification:**
```bash
# Test preview opens browser (manual check - browser should open)
npx tsx -e "import { showPreview } from './src/workflows/preview.js'; import { rm } from 'node:fs/promises'; const buf = Buffer.from('iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mNk+M9QDwADhgGAWjR9awAAAABJRU5ErkJggg==', 'base64'); const tempDir = await showPreview(buf); console.log('Preview opened, temp dir:', tempDir); await new Promise(r => setTimeout(r, 3000)); await rm(tempDir, { recursive: true, force: true }); console.log('Cleanup complete')"
```

3. **TypeScript compilation:**
```bash
npx tsc --noEmit
```

All checks must pass.
</verification>

<success_criteria>
- [x] generatePreviewHTML converts Buffer to base64 data URL and returns valid HTML
- [x] HTML template has dark background, centered image, responsive sizing
- [x] CleanupManager singleton with register/cleanup methods exists
- [x] SIGINT/SIGTERM handlers registered and call cleanup before exit
- [x] showPreview creates temp directory with unique name
- [x] showPreview writes HTML file and opens browser via pathToFileURL
- [x] showPreview returns temp directory path for caller cleanup
- [x] Browser opens and displays image without CORS errors
- [x] All files compile with TypeScript without errors
- [x] Verification tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/02-workflow-orchestration/02-01-SUMMARY.md` documenting:
- Preview system architecture (base64 data URLs vs file:// protocol)
- Cleanup manager pattern (signal handlers, Promise.allSettled)
- Integration points for Plan 02 orchestrator
- Any deviations or issues encountered
</output>
